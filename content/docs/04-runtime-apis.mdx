---
title: Runtime APIs
description: Use built-in runtime APIs inside actions to perform side effects such as logging and outbound HTTP requests.
---

## Overview

Titan provides a small, intentional set of **runtime APIs** that are available inside **actions**.  
These APIs allow actions to perform controlled side effects while preserving Titan‚Äôs performance, determinism, and Rust-backed execution model.

Runtime APIs are exposed through the global `t` object.

> Runtime APIs are **not available in routes**.  
> They are designed exclusively for use inside actions.

---

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

<Accordions>
<Accordion title="t.log() ‚Äî Structured logging">
`t.log()` is Titan‚Äôs built-in logging API.  
It allows actions to emit logs that are collected and handled by the native Rust server.

```js
t.log("User login started")
```

### Logging structured data

`t.log()` accepts any serializable JavaScript value.

```js title="app/actions/login.js"
t.log({
  action: "login",
  userId: req.params.id,
})
```

* Objects are logged as structured data
* Logs are serialized safely
* No `console.log` dependency

### Why `t.log` exists

* Logs are routed through Rust (not stdout hacks)
* Consistent formatting across environments
* Safe to use in production
* Zero Node.js dependency

Use `t.log()` instead of `console.log()` in all actions.
</Accordion>

<Accordion title="t.fetch() ‚Äî Outbound HTTP requests">
`t.fetch()` allows actions to make outbound HTTP requests.
It follows a familiar `fetch`-style API while executing through Titan‚Äôs Rust networking layer.

```js
const res = t.fetch("https://api.example.com/users")
```

### Basic usage

```js
export default function example(req) {
  const res = t.fetch("https://api.example.com/data")
  return res
}
```

* Executes via Rust-native HTTP client
* No Node.js networking stack
* Predictable performance

### Sending a JSON request

```js title="app/actions/login.js"
t.fetch("https://api.example.com/login", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: {
    email: req.body.email,
  },
})
```

* Objects passed as `body` are serialized automatically
* Headers are optional
* No manual JSON handling required

### Reading the response

`t.fetch()` returns a parsed response object.

```js
const res = t.fetch("https://api.example.com/user/1")

return {
  status: res.status,
  data: res.body,
}
```

* `res.status` ‚Üí HTTP status code
* `res.body` ‚Üí parsed response body
* Errors propagate naturally to the caller

### Error behavior

If a request fails:

* Network errors throw immediately
* Non-2xx responses are still returned
* You control how failures are handled

```js
const res = t.fetch(url)

if (res.status !== 200) {
  t.log("Upstream service failed")
}
```
</Accordion>

<Accordion title="t.jwt ‚Äî JSON Web Tokens">
`t.jwt` provides **Rust-backed JSON Web Token (JWT)** signing and verification.
All cryptographic operations are executed natively in Rust.

There is **no Node.js JWT library**, no JS crypto, and no async behavior.

### `t.jwt.sign()`

Creates and signs a JWT.

```js
const token = t.jwt.sign(
  { userId: 1, email: "admin@ez.app" },
  processe.env.JWT_SECRET,
  { expiresIn: "1m" }
)
```

#### Parameters

* **payload** ‚Äî Object to encode into the token
* **secret** ‚Äî HMAC secret key
* **options** *(optional)*

#### Supported `expiresIn` formats

| Value   | Meaning    |
| ------- | ---------- |
| `60`    | 60 seconds |
| `"1m"`  | 1 minute   |
| `"1h"`  | 1 hour     |
| `"30d"` | 30 days    |

Expiration is converted into a JWT `exp` claim **inside Rust**.

> If `expiresIn` is omitted, the token does not expire.

### `t.jwt.verify()`

Verifies a JWT and returns its decoded payload.

```js
const payload = t.jwt.verify(token, processe.env.JWT_SECRET)
```

#### Behavior

* Signature is validated
* `exp` (expiration) is enforced
* Expired tokens throw immediately
* Time comparison is done in Rust

```js
try {
  const payload = t.jwt.verify(token, processe.env.JWT_SECRET)
} catch {
  // invalid or expired token
}
```

`jwt.io` may decode expired tokens, but Titan **correctly rejects them**.

### Error log on expired token
<img
  src="/err-log-token-exp.png"
  alt="Titan Runtime APIs"
  style={{ borderRadius: "12px" }}
/>
</Accordion>

<Accordion title="t.password ‚Äî Password hashing">
`t.password` provides secure password hashing and verification using **Rust-native cryptography**.

Passwords are **never processed by JavaScript libraries**.

### `t.password.hash()`

Hashes a plaintext password.

```js
const hash = t.password.hash("admin123")
```

* Uses a secure adaptive hashing algorithm
* Safe to store in a database
* Deterministic and production-ready

### `t.password.verify()`

Verifies a password against a stored hash.

```js
const ok = t.password.verify("admin123", hash)
```

* Returns `true` if the password matches
* Returns `false` otherwise
* No timing-sensitive logic in JavaScript

### Security guarantees

* No plaintext passwords stored
* No JS-side cryptography
* No implicit expiration handling
* All verification enforced in Rust
</Accordion>

<Accordion title="t.db ‚Äî Titan Database API">
Titan includes a built-in, high-performance PostgreSQL client available directly in your runtime via the global `t` object. This allows you to interact with your data without installing any external Node.js dependencies.

### üöÄ Quick Start

1. **Add your connection string** to your `.env` file:
   ```bash
   DATABASE_URL="postgres://user:password@localhost:5432/mydb"
   ```

2. **Connect and Query** in your action:
   ```js title="app/actions/get_users.js"
   export default function(req) {
       // 1. Connect
       const db = t.db.connect(process.env.DATABASE_URL);

       // 2. Query
       const users = db.query("SELECT * FROM users WHERE active = $1");

       // 3. Return
       return users;
   }
   ```

### üìö API Reference: `t.db.connect(connectionString)`

Establishes a synchronous connection to the PostgreSQL database.

- **Arguments**:
  - `connectionString` *(string)*: A standard PostgreSQL connection URI (e.g., `postgres://...`).
- **Returns**: A `DbConnection` object.

### `db.query(sql, params)`

Executes a SQL query against the database.

- **Arguments**:
  - `sql` *(string)*: The SQL statement to execute. Use `$1`, `$2`, etc., for parameters.
  - `params` *(Array, optional)*: An array of values to bind to the placeholders.
- **Returns**: `Array<Object>` - An array of rows, where each row is an object with column names as keys.

#### Supported Data Types

| JavaScript Type | PostgreSQL Type |
| :--- | :--- |
| `String` | `TEXT`, `VARCHAR`, `CHAR` |
| `Number` | `INT`, `FLOAT`, `DOUBLE` |
| `Boolean` | `BOOLEAN` |
| `null` | `NULL` |
| `Object/Array` | `JSON`, `JSONB` |

### üõ† Best Practices

### 1. Externalize SQL Files (`t.read`)

Don't clutter your JavaScript with long SQL strings. Titan provides `t.read()` to read files from your project root.

**Folder Structure:**
```
my-project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ actions/
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îî‚îÄ‚îÄ get_active_users.sql   <-- Your SQL file
‚îî‚îÄ‚îÄ .env
```

```sql title="app/db/get_active_users.sql"
SELECT id, email, full_name
FROM users
WHERE 
    active = $1
    AND created_at > $2
ORDER BY created_at DESC;
```

```js title="app/actions/users.js"
export default function(req) {
    const db = t.db.connect(process.env.DATABASE_URL);
    
    // Read SQL from file
    const sql = t.read("../db/get_active_users.sql");
    
    return db.query(sql);
}
```

### 2. Create a Shared DB Module

Instantiate your connection once in a helper file to keep your code DRY.

```js title="app/actions/db.js"
// Export a ready-to-use db instance
export const db = t.db.connect(process.env.DATABASE_URL);
```

```js title="app/actions/any.js"
import { db } from "./db.js";

export default function(req) {
    return db.query("SELECT version()");
}
```

### ‚ö†Ô∏è Important Notes

- **Synchronous Execution**: Database queries in Titan are currently synchronous. This simplifies logic but means the query blocks the specific action execution. Titan handles concurrency at the server thread level.
- **Connection Pooling**: Titan manages connections for you, but `t.db.connect` aims to be lightweight.
- **Environment Variables**: Always use `process.env` for sensitive credentials. Never hardcode passwords.
</Accordion>

<Accordion title="t.read() ‚Äî Native File Reader">
Titan provides an optimized file reading API.

```js
const config = t.read("./config.json")
```

- Synchronous and fast (Rust-backed)
- Root-scoped for security
- Ideal for SQL files, templates, or static config.
</Accordion>
</Accordions>


---

## Where Runtime APIs can be used

| Location   | Allowed |
| ---------- | ------- |
| Routes     | ‚ùå No    |
| Actions    | ‚úÖ Yes   |
| Build time | ‚ùå No    |

Runtime APIs execute **only at request time**.

---

## Design philosophy

Titan‚Äôs runtime APIs are:

* Minimal by design
* Explicitly scoped
* Rust-backed

---

## Where Runtime APIs can be used

| Location   | Allowed |
| ---------- | ------- |
| Routes     | ‚ùå No    |
| Actions    | ‚úÖ Yes   |
| Build time | ‚ùå No    |

Runtime APIs execute **only at request time**.

---

## Design philosophy

Titan‚Äôs runtime APIs are:

* Minimal by design
* Explicitly scoped
* Rust-backed
* Production-safe

There is no hidden magic and no implicit globals beyond `t`

---

## Mental model

> Routes define structure
> Actions define behavior
> Runtime APIs perform side effects
> Rust executes everything

This keeps Titan applications predictable, fast, and maintainable.
