---
title: Runtime APIs
description: Use built-in runtime APIs inside actions to perform side effects such as logging and outbound HTTP requests.
---

## Overview

Titan provides a small, intentional set of **runtime APIs** that are available inside **actions**.  
These APIs allow actions to perform controlled side effects while preserving Titan‚Äôs performance, determinism, and Rust-backed execution model.

Runtime APIs are exposed through the global `t` object.

> Runtime APIs are **not available in routes**.  
> They are designed exclusively for use inside actions.

---

## `t.log()` ‚Äî Structured logging

`t.log()` is Titan‚Äôs built-in logging API.  
It allows actions to emit logs that are collected and handled by the native Rust server.

```js
t.log("User login started")
````

### Logging structured data

`t.log()` accepts any serializable JavaScript value.

```js title="app/actions/login.js"
t.log({
  action: "login",
  userId: req.params.id,
})
```

* Objects are logged as structured data
* Logs are serialized safely
* No `console.log` dependency

### Why `t.log` exists

* Logs are routed through Rust (not stdout hacks)
* Consistent formatting across environments
* Safe to use in production
* Zero Node.js dependency

Use `t.log()` instead of `console.log()` in all actions.

---

## `t.fetch()` ‚Äî Outbound HTTP requests

`t.fetch()` allows actions to make outbound HTTP requests.
It follows a familiar `fetch`-style API while executing through Titan‚Äôs Rust networking layer.

```js
const res = t.fetch("https://api.example.com/users")
```

### Basic usage

```js
export default function example(req) {
  const res = t.fetch("https://api.example.com/data")
  return res
}
```

* Executes via Rust-native HTTP client
* No Node.js networking stack
* Predictable performance

---

### Sending a JSON request

```js title="app/actions/login.js"
t.fetch("https://api.example.com/login", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: {
    email: req.body.email,
  },
})
```

* Objects passed as `body` are serialized automatically
* Headers are optional
* No manual JSON handling required

---

### Reading the response

`t.fetch()` returns a parsed response object.

```js
const res = t.fetch("https://api.example.com/user/1")

return {
  status: res.status,
  data: res.body,
}
```

* `res.status` ‚Üí HTTP status code
* `res.body` ‚Üí parsed response body
* Errors propagate naturally to the caller

---

### Error behavior

If a request fails:

* Network errors throw immediately
* Non-2xx responses are still returned
* You control how failures are handled

```js
const res = t.fetch(url)

if (res.status !== 200) {
  t.log("Upstream service failed")
}
```

---

## `t.jwt` ‚Äî JSON Web Tokens

`t.jwt` provides **Rust-backed JSON Web Token (JWT)** signing and verification.
All cryptographic operations are executed natively in Rust.

There is **no Node.js JWT library**, no JS crypto, and no async behavior.

---

### `t.jwt.sign()`

Creates and signs a JWT.

```js
const token = t.jwt.sign(
  { userId: 1, email: "admin@ez.app" },
  processe.env.JWT_SECRET,
  { expiresIn: "1m" }
)
````

#### Parameters

* **payload** ‚Äî Object to encode into the token
* **secret** ‚Äî HMAC secret key
* **options** *(optional)*

#### Supported `expiresIn` formats

| Value   | Meaning    |
| ------- | ---------- |
| `60`    | 60 seconds |
| `"1m"`  | 1 minute   |
| `"1h"`  | 1 hour     |
| `"30d"` | 30 days    |

Expiration is converted into a JWT `exp` claim **inside Rust**.

> If `expiresIn` is omitted, the token does not expire.

---

### `t.jwt.verify()`

Verifies a JWT and returns its decoded payload.

```js
const payload = t.jwt.verify(token, processe.env.JWT_SECRET)
```

#### Behavior

* Signature is validated
* `exp` (expiration) is enforced
* Expired tokens throw immediately
* Time comparison is done in Rust

```js
try {
  const payload = t.jwt.verify(token, processe.env.JWT_SECRET)
} catch {
  // invalid or expired token
}
```

`jwt.io` may decode expired tokens, but Titan **correctly rejects them**.

### Error log on expired token
<img
  src="/err-log-token-exp.png"
  alt="Titan Runtime APIs"
  style={{ borderRadius: "12px" }}
/>

---

## `t.password` ‚Äî Password hashing

`t.password` provides secure password hashing and verification using **Rust-native cryptography**.

Passwords are **never processed by JavaScript libraries**.

---

### `t.password.hash()`

Hashes a plaintext password.

```js
const hash = t.password.hash("admin123")
```

* Uses a secure adaptive hashing algorithm
* Safe to store in a database
* Deterministic and production-ready

---

### `t.password.verify()`

Verifies a password against a stored hash.

```js
const ok = t.password.verify("admin123", hash)
```

* Returns `true` if the password matches
* Returns `false` otherwise
* No timing-sensitive logic in JavaScript

---

## Security guarantees

* No plaintext passwords stored
* No JS-side cryptography
* No implicit expiration handling
* All verification enforced in Rust

---


## üêò Titan Database API (`t.db`)

Titan includes a built-in, high-performance PostgreSQL client available directly in your runtime via the global `t` object. This allows you to interact with your data without installing any external Node.js dependencies.

---

### üöÄ Quick Start

1. **Add your connection string** to your `.env` file:
   ```bash
   DATABASE_URL="postgres://user:password@localhost:5432/mydb"
   ```

2. **Connect and Query** in your action:
   ```js title="app/actions/get_users.js"
   export default function(req) {
       // 1. Connect
       const db = t.db.connect(process.env.DATABASE_URL);

       // 2. Query
       const users = db.query("SELECT * FROM users WHERE active = $1");

       // 3. Return
       return users;
   }
   ```

---

### üìö API Reference: `t.db.connect(connectionString)`

Establishes a synchronous connection to the PostgreSQL database.

- **Arguments**:
  - `connectionString` *(string)*: A standard PostgreSQL connection URI (e.g., `postgres://...`).
- **Returns**: A `DbConnection` object.

### `db.query(sql, params)`

Executes a SQL query against the database.

- **Arguments**:
  - `sql` *(string)*: The SQL statement to execute. Use `$1`, `$2`, etc., for parameters.
  - `params` *(Array, optional)*: An array of values to bind to the placeholders.
- **Returns**: `Array<Object>` - An array of rows, where each row is an object with column names as keys.

#### Supported Data Types

Titan automatically maps JavaScript types to PostgreSQL types and vice versa:

| JavaScript Type | PostgreSQL Type |
| :--- | :--- |
| `String` | `TEXT`, `VARCHAR`, `CHAR` |
| `Number` | `INT`, `FLOAT`, `DOUBLE` |
| `Boolean` | `BOOLEAN` |
| `null` | `NULL` |
| `Object/Array` | `JSON`, `JSONB` |

---

### üõ† Best Practices

### 1. Externalize SQL Files (`t.read`)

Don't clutter your JavaScript with long SQL strings. Titan provides `t.read()` to read files from your project root.

**Folder Structure:**
```
my-project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îî‚îÄ‚îÄ actions/
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îî‚îÄ‚îÄ get_active_users.sql   <-- Your SQL file
‚îî‚îÄ‚îÄ .env
```

```sql title="app/db/get_active_users.sql"
SELECT id, email, full_name
FROM users
WHERE 
    active = $1
    AND created_at > $2
ORDER BY created_at DESC;
```

```js title="app/actions/users.js"
export default function(req) {
    const db = t.db.connect(process.env.DATABASE_URL);
    
    // Read SQL from file
    const sql = t.read("../db/get_active_users.sql");
    
    return db.query(sql);
}
```

### 2. Create a Shared DB Module

Instantiate your connection once in a helper file to keep your code DRY.

```js title="app/actions/db.js"
// Export a ready-to-use db instance
export const db = t.db.connect(process.env.DATABASE_URL);
```

```js title="app/actions/any.js"
import { db } from "./db.js";

export default function(req) {
    return db.query("SELECT version()");
}
```

---

### ‚ö†Ô∏è Important Notes

- **Synchronous Execution**: Database queries in Titan are currently synchronous. This simplifies logic but means the query blocks the specific action execution. Titan handles concurrency at the server thread level.
- **Connection Pooling**: Titan manages connections for you, but `t.db.connect` aims to be lightweight.
- **Environment Variables**: Always use `process.env` for sensitive credentials. Never hardcode passwords.


---

## Where Runtime APIs can be used

| Location   | Allowed |
| ---------- | ------- |
| Routes     | ‚ùå No    |
| Actions    | ‚úÖ Yes   |
| Build time | ‚ùå No    |

Runtime APIs execute **only at request time**.

---

## Design philosophy

Titan‚Äôs runtime APIs are:

* Minimal by design
* Explicitly scoped
* Rust-backed
* Production-safe

There is no hidden magic and no implicit globals beyond `t`

---

## Mental model

> Routes define structure
> Actions define behavior
> Runtime APIs perform side effects
> Rust executes everything

This keeps Titan applications predictable, fast, and maintainable.

## Example Actions

```json title="credentials"
{
  "email": "admin@ez.app",
  "password": "mypassword123"
}
```
### Login to the account
```js title="app/actions/login.js"
export function login(req) {
    const { email, password } = req.body || {}
  
    if (!email || !password) {
      return {
        status: 400,
        json: { error: "Email and password required" }
      }
    }
  
    // ‚ö†Ô∏è Mock DB
    const user = {
      id: 1,
      email: "admin@ez.app",
      passwordHash: "$2b$12$MJwttSgptEQJCkPJ.J8mce1xxtmxlJPCsISvc1WEzR6mqdD/ZJyOC"
    }
  
    if (email !== user.email) {
      return {
        status: 401,
        json: { error: "Invalid credentials" }
      }
    }
  
    const ok = t.password.verify(password, user.passwordHash)
  
    if (!ok) {
      return {
        status: 401,
        json: { error: "Invalid credentials" }
      }
    }
  
    const token = t.jwt.sign(
      { userId: user.id, email: user.email },
      processe.env.JWT_SECRET,
      { expiresIn: "1m" }   // üëà 1 minute token
    )
  
    return {
      status: 200,
      json: {
        token,
        expiresIn: "1 minute"
      }
    }
  }
```
### Register a account
```js title="app/actions/register.js"
export function register(req) {
    const { email, password } = req.body || {}
  
    if (!email || !password) {
      return {
        status: 400,
        json: { error: "Email and password are required" }
      }
    }
  
    // ‚ö†Ô∏è Mock DB
    // IMPORTANT: store passwordHash, never password
    const passwordHash = t.password.hash(password)
  
    // pretend we saved this
    const user = {
      id: 1,
      email,
      passwordHash
    }
  
    return {
      status: 201,
      json: {
        message: "Account created",
        user: {
          id: user.id,
          email: user.email,
          passwordHash: user.passwordHash
        }
      }
    }
  }

```
### Get the user details

```js title="app/actions/getUser.js"
export function getUser(req) {
    const { token } = req.body || {}
  
    const payload = t.jwt.verify(token, processe.env.JWT_SECRET)
  
    return {
      status: 200,
      json: {
        user: payload
      }
    }
  }
```

### A example of regiter user with supabse postgress:

**Don't forget to add this environment variables in `.env` file `SUPABASE_ANON_KEY`, `SUPABASE_PROJECT_ID`**

```js title="app/actions/register.js"
export default function register(req) {
  const { email, password } = req.body;

  if (!email || !password) {
    return { status: 400, error: "Email and password are required" };
  }

  const password_hash = t.password.hash(password);

  // HARD GUARD ‚Äî REQUIRED
  if (typeof password_hash !== "string") {
    return { status: 500, error: "Password hashing failed" };
  }

  const res = t.fetch(
    `https://${process.env.SUPABASE_PROJECT_ID}.supabase.co/rest/v1/users`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "apikey": process.env.SUPABASE_ANON_KEY,
        "Authorization": `Bearer ${process.env.SUPABASE_ANON_KEY}`,
        "Prefer": "return=representation"
      },
      body: {
        email,
        password_hash
      }
    }
  );

  // Duplicate email
  if (res.status === 409) {
    return { status: 409, error: "Email already registered" };
  }

  // Any other failure
  if (res.status < 200 || res.status >= 300) {
    return {
      status: res.status,
      error: res.body || "User creation failed"
    };
  }
  t.log("SUPABASE RES:", res);

  return {
    status: 201,
    message: "User registered successfully",
  };
}
```