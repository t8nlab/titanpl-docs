---
title: How Titan Planet Works
description: A step-by-step walkthrough of Titan’s build pipeline, runtime model, performance characteristics, and native execution flow
---

import { Callout } from "fumadocs-ui/components/callout"
import { Steps, Step } from "fumadocs-ui/components/steps"
import { File, Folder, Files } from 'fumadocs-ui/components/files';

## Overview

**Titan Planet** is a **JavaScript-first backend framework** where application logic is written in JavaScript, while **routing, concurrency, and execution are handled by a native Rust server**.

You write JavaScript.  
Titan builds Rust.  
Production runs a **single native binary**.

<Callout type="info">
Titan does not run a JavaScript server in production.  
JavaScript executes only as a controlled logic layer inside Rust.
</Callout>

---

## High-Level Idea

Titan is designed around a **strict responsibility split**.

### JavaScript Responsibility

- Route declarations
- Business logic (actions)
- Validation and transformations

### Rust Responsibility

- HTTP server (Axum)
- Routing and method matching
- Concurrency and async I/O
- Process lifecycle and deployment

<Callout type="note">
JavaScript never owns the request lifecycle.  
Rust always does.
</Callout>

---

## Step 1 — Writing Routes

Routes are declared using Titan’s DSL in:


```js title="app/app.js"
t.post("/login").action("login")
t.post("/ca").action("register")
t.post("/").action("hello")
````

<Callout type="warning">
This file is parsed at <strong>build time</strong>.  
It is <strong>not executed per request</strong>.
</Callout>

At runtime, JavaScript never performs routing.

---

## Step 2 — Action Authoring

Each action lives in: `
app/actions/
`

Example:

```js title="app/actions/"
export default function login(req) {
  return { ok: true }
}
```

These files contain **pure application logic only**.

* No HTTP server
* No routing
* No async orchestration 
* No event loop control

<Callout type="info">
Actions run only after Rust has already resolved the request.
</Callout>

<Callout type="success">
Titan does not expose an async runtime to JavaScript.  
Rust (Tokio) owns all async I/O and scheduling; JavaScript executes synchronously inside that boundary.
</Callout>


---

## Step 3 — Build-Time Compilation

When you run:

```bash
tit build
```

Titan performs **deterministic compile-time steps**.

<Steps>
  <Step title="Generate routes.json">
    A static routing table is generated for the Rust server.
  </Step>

  <Step title="Generate action_map.json">
    Routes are mapped to action identifiers.
  </Step>

  <Step title="Bundle actions with esbuild">
    Each action is bundled into a deterministic <code>.jsbundle</code> file, using ``esbuild``
  </Step>

  <Step title="Compile native Rust server">
    Axum, runtime code, and the embedded JS engine are compiled into one binary.
  </Step>
</Steps>

<Callout type="success">
No routing logic, module resolution, or imports exist at runtime.
</Callout>

---

## Step 4 — Server Runtime Layout

All production artifacts live inside the **server runtime boundary**.

  <Folder name="server" defaultOpen>
    <Folder name="actions" defaultOpen>
      <File name="hello.jsbundle" />
      <File name="login.jsbundle" />
      <File name="register.jsbundle" />
    </Folder>

<File name="routes.json" />
<File name="action_map.json" />
<File name="Cargo.toml" />
<File name="Cargo.lock" />
<Folder name="target" />


  </Folder>


<Callout type="warning">
Everything inside <code>server/</code> belongs to the native execution layer.  
JavaScript never reads or modifies these files at runtime.
</Callout>

---

## Step 5 — Runtime Execution Flow

When a request hits production:

1. HTTP request reaches the **native Rust server**
2. Rust matches the route using `routes.json`
3. Rust resolves the action using `action_map.json`
4. The bundled JS action executes inside the embedded JS engine
5. The result is returned to the client

<Callout type="info">
Routing, concurrency, and I/O are completed <strong>before</strong> JavaScript runs.
</Callout>


---

## Performance & Speed

### Does using V8 make Titan slow?

**No — and this is by design.**

Titan does **not** use JavaScript as a server runtime.

V8 executes **only**:

* Bundled action logic
* Deterministic business rules
* JSON parsing and transformations
* Short-lived, bounded computation

V8 does **not** execute:

* HTTP servers
* Event loops
* Async schedulers
* Threads
* Networking
* File I/O
* System calls

All performance-critical responsibilities are handled by **Rust + Axum + Tokio**.

<Callout type="success">
JavaScript is not in the hot path of networking, concurrency, or I/O.
</Callout>

---

### Why this is fast in practice

* Routing is static and Rust-owned
* No JavaScript router
* No dynamic module resolution
* No runtime imports
* No promise-driven request lifecycle
* No Node.js runtime overhead
* No garbage-heavy server abstractions

JavaScript runs **only when business logic is required**, and only for a **short, strictly bounded duration**.

---

## JavaScript Engine Choice (V8, Not Node.js)

Titan Planet now uses the **V8 JavaScript engine** as its embedded runtime.

This does **not** mean Titan uses Node.js.

### What V8 Is (and What It Is Not)

**V8 is:**

* A JavaScript execution engine
* A bytecode interpreter + JIT compiler
* A garbage-collected runtime core

**V8 is not:**

* Node.js
* A web server
* An event loop
* A package manager
* An async I/O runtime

Node.js is a **platform built on top of V8**, not V8 itself.

<Callout type="info">
Using V8 does not imply Node.js.  
Titan embeds V8 directly, without Node’s APIs, runtime, or event loop.
</Callout>

---

### What Titan Explicitly Does *Not* Include

Even with V8, Titan intentionally does **not** include:

* Node.js runtime
* libuv
* Node event loop
* Node core modules (`fs`, `net`, `http`, etc.)
* Node globals (`process`, `Buffer`, etc.)

JavaScript code in Titan **cannot** start servers, manage async I/O, or control scheduling.

---

### Responsibility Boundary (Final Mental Model)

* **Rust + Tokio** own:

  * Concurrency
  * Async scheduling
  * Networking
  * Timers
  * File and system I/O

* **JavaScript (V8)** owns:

  * Application logic
  * Validation
  * Data transformation
  * Pure computation

<Callout type="success">
V8 executes JavaScript.  
Rust executes the server.
</Callout>

---



## Final Output

After a successful build, Titan produces a single binary: `
server/target/titan-server
`

This binary contains:

* Axum HTTP server
* Routing metadata
* Bundled JavaScript logic
* Embedded JavaScript runtime

<Callout type="success">
No Node.js.  
No runtime JS server.  
One native binary: <strong>titan-server</strong>.
</Callout>

---

## One-Sentence Summary

<Callout type="info">
Titan Planet is a JavaScript-first backend framework that compiles routes and actions into static metadata and executes them inside a native Rust server, producing a single high-performance binary for production.
</Callout>
