---
title: Actions
description: Execute request-aware business logic in JavaScript or Rust, compiled and embedded into Titan‚Äôs native server.
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Callout } from 'fumadocs-ui/components/callout';

<Callout title="Migrating to Hybrid Actions" type="warn">
  To use **Rust Actions** in an existing project:
  
  1. **Update CLI**: `npm install -g @ezetgalaxy/titan`
  2. **Enable Template**: Add to `package.json`:
     ```json
     "titan": { "template": "rust" }
     ```
  3. **Sync Orbit**: Run `titan update` to scaffold the native core.
</Callout>

## What is an Action?

An **action** is a function that executes when a route is matched.  
Actions receive the full request context and are responsible for all **dynamic behavior** in a Titan application.

Routes define *what* endpoint exists.  
Actions define *what happens* when that endpoint is called.

```js title="app/actions/hello.js"
export function run(req) {
  return { ok: true }
}
```

---

## ‚ö° Hybrid Action System

Titan is unique because it allows you to write endpoints in **both** JavaScript and Rust within the same project.

### üü° JavaScript Actions (`app/actions/hello.js`)
Perfect for business logic, rapid prototyping, and IO-bound tasks.
```javascript
export function run(req) {
    t.log("Handling user request...");
    return { 
        message: "Hello from JavaScript!",
        user_id: req.params.id 
    };
}
```

### üî¥ Rust Actions <span className="inline-flex items-center rounded-full border bg-blue-500/10 border-blue-500/20 px-2 py-0.5 text-[10px] font-medium text-blue-500 ml-2">BETA</span>
Perfect for heavy computation, encryption, image processing, or low-level system access.

```rust title="app/actions/compute.rs"
use axum::{response::{IntoResponse, Json}, http::Request, body::Body};
use serde_json::json;

pub async fn run(req: Request<Body>) -> impl IntoResponse {
    t.log("Processed 1M records in Rust");
    Json(json!({ "result": "Processed 1M records in Rust" }))
}
```

**Titan automatically detects, compiles, and routes both types.**
* `.js` files are bundled with esbuild.
* `.rs` files are compiled into the native binary.
* Both share the same `routes.json` or `app.js` configuration.

---

## ‚öôÔ∏è Enabling Rust Actions
To enable Rust support in an existing Titan project:

1. **Update your CLI** to the latest version:
   ```bash
   npm install -g @ezetgalaxy/titan
   ```

2. **Update `package.json`** to include the rust template:
   ```json
   {
     "titan": {
       "template": "rust"
     }
   }
   ```

3. **Run the update command** to generate the necessary native files:
   ```bash
   titan update
   ```

---

## When to use an Action

Use an action whenever you need:

* Access to request data (`params`, `query`, `body`, `headers`)
* Conditional logic or validation
* Database or external service calls
* Dynamic response generation

Static responses should use `reply()` instead.

---

## Connecting a Route to an Action

Routes reference actions by name.

```js title="app.js"
t.get("/user/:id<number>").action("getUser")
```

Titan automatically resolves this to:
`
app/actions/getUser.js
`
or
`
app/actions/getUser.rs
`

No imports or wiring are required.

---

## Action file structure

Actions live in the `app/actions` directory.

<Files>
  <Folder name="app" defaultOpen>
    <File name="app.js" />
    <Folder name="actions" defaultOpen>
      <File name="getUser.js" />
      <File name="compute.rs" />
      <File name="login.js" />
    </Folder>
  </Folder>
</Files>


Each file exports a single function. In JavaScript, it's the `run` or default function. In Rust, it's the `run` function.

---

## Accessing route parameters (`req.params`)

Typed route parameters are validated before the action runs.

```js title="app/actions/getUser.js"
export function getUser(req) {
  return {
    userId: req.params.id,
  }
}
```

* `req.params.id` is guaranteed to match the declared type
* Invalid parameters never reach the action

---

## Reading query parameters (`req.query`)

Query strings are parsed automatically.

```js title="app/actions/search.js"
export function search(req) {
  return {
    q: req.query.q,
  }
}
```

Request:

```
GET /search?q=titan
```

Result:

```json
{ "q": "titan" }
```

---

## Reading request bodies (`req.body`)

Titan parses request bodies based on content type.

```js title="app/actions/login.js"
export function login(req) {
  return {
    email: req.body.email,
  }
}
```

* JSON bodies are parsed automatically
* Invalid payloads are rejected before execution

---

## Returning responses

Actions return plain JavaScript values (JS) or `IntoResponse` (Rust).

```js title="app/actions/example.js"
export function example(req) {
  return {
    success: true,
  }
}
```

Titan automatically:

* Serializes objects to JSON
* Sets appropriate response headers
* Sends the response from native Rust

---

## Returning HTTP errors

Throwing an error signals a failed request.

```js
export function protectedAction(req) {
  if (!req.headers.authorization) {
    throw new Error("Unauthorized")
  }

  return { ok: true }
}
```

Titan converts errors into proper HTTP responses or log on the terminal.

---

## Synchronous and deterministic execution (JS)

JavaScript actions execute synchronously inside Titan‚Äôs embedded JavaScript engine.

* No Node.js runtime
* No event loop
* No background async side effects

This ensures predictable execution and easy reasoning about behavior.

---

## Separation of responsibilities

| Layer       | Responsibility                      |
| ----------- | ----------------------------------- |
| Routes      | URL structure and HTTP methods      |
| Actions     | Request handling and logic          |
| Rust server | Execution, routing, and performance |

This separation keeps applications clean, testable, and maintainable.

---

## Mental model

> Routes describe **structure**
> Actions handle **behavior**
> Titan compiles both into **Rust**

This model scales cleanly from small APIs to large production systems.
