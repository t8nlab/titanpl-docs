---
title: Actions
description: Execute request-aware business logic in JavaScript, TypeScript (Beta), or Rust, compiled and embedded into Titan‚Äôs native server.
---

import { File, Folder, Files } from 'fumadocs-ui/components/files';
import { Callout } from 'fumadocs-ui/components/callout';

## What is an Action?

An **action** is a function that executes when a route is matched.  
Actions receive the full request context and are responsible for all **dynamic behavior** in a Titan application.

Routes define *what* endpoint exists.  
Actions define *what happens* when that endpoint is called.

Titan is unique because it allows you to write endpoints in **JavaScript**, **TypeScript** (Beta), and **Rust** within the same project.

---

## üîµ TypeScript Actions (`.ts`)

<span className="inline-flex items-center rounded-full border bg-green-500/10 border-green-500/20 px-2 text-[10px] font-medium text-green-500">BETA</span>

Fully typed, strict, and auto-compiled. Titan enforces zero type errors before running.

```typescript title="app/actions/hello.ts"

import { defineAction } from "../../titan/titan";

interface HelloResponse {
    message: string;
    user_name: string;
}

// "defineAction" provides automatic type inference for "req"
export const hello = defineAction((req): HelloResponse => {
    t.log("Handling request with strict types...");

    return { 
        message: "Hello from TypeScript!",
        user_name: req.body.name || "Guest"
    };
});
```

### Strict Type Safety
If `titan dev` detects a type error, the server **will not run**. This ensures you never ship or test broken code.

---

## üü° JavaScript Actions (`.js`)

<span className="inline-flex items-center rounded-full border bg-yellow-500/10 border-yellow-500/20 px-2 text-[10px] font-medium text-yellow-500">STANDARD</span>

Perfect for business logic, rapid prototyping, and IO-bound tasks.

```javascript title="app/actions/hello.js"
export function run(req) {
    t.log("Handling user request...");
    return { 
        message: "Hello from JavaScript!",
        user_id: req.params.id 
    };
}
```

---

## üî¥ Rust Actions (`.rs`)

<span className="inline-flex items-center rounded-full border bg-blue-500/10 border-blue-500/20 px-2 text-[10px] font-medium text-blue-500">BETA</span>

Perfect for heavy computation, encryption, image processing, or low-level system access.

> **Note:** The Native Rust Action API is currently in **Beta**.

```rust title="app/actions/compute.rs"
use axum::{response::{IntoResponse, Json}, http::Request, body::Body};
use serde_json::json;

pub async fn run(req: Request<Body>) -> impl IntoResponse {
    // Perform heavy computation here
    t.log("Processed 1M records in Rust");
    Json(json!({ "result": "Processed 1M records in Rust" }))
}
```

---

## ‚ö° Hybrid Action System

Titan automatically detects, compiles, and routes all types.

* `.ts` files are type-checked and compiled.
* `.js` files are bundled.
* `.rs` files are compiled into the native binary.
* All share the same `routes.json` configuration.

| Mode | Status | Description |
| :--- | :--- | :--- |
| **JavaScript** | ‚úÖ Stable | Standard JS development. |
| **TypeScript** | ‚ö†Ô∏è Beta | Strict typing usage. |
| **Rust + JS** | ‚ö†Ô∏è Beta | Hybrid runtime with Rust actions. |
| **Rust + TS** | ‚ö†Ô∏è Beta | Hybrid runtime with Rust and TS actions. |

---

## ‚öôÔ∏è Enabling Rust Actions
To enable Rust support in an existing Titan project:

1. **Update your CLI** to the latest version:
   ```bash
   npm install -g @ezetgalaxy/titan
   ```

2. **Update `package.json`** to include the rust template:
   ```json
   {
     "titan": {
       "template": "rust"
     }
   }
   ```

3. **Run the update command** to generate the necessary native files:
   ```bash
   titan update
   ```

---

## When to use an Action

Use an action whenever you need:

* Access to request data (`params`, `query`, `body`, `headers`)
* Conditional logic or validation
* Database or external service calls
* Dynamic response generation

Static responses should use `reply()` instead.

---

## Connecting a Route to an Action

Routes reference actions by name.

```js title="app.js"
t.get("/user/:id<number>").action("getUser")
```

Titan automatically resolves this to:
* `app/actions/getUser.ts`
* `app/actions/getUser.js`
* `app/actions/getUser.rs`

No imports or wiring are required.

<Callout title="Naming Convention Warning" type="warn">
  You **MUST** ensure the following match exactly:
  1. The **file name** in `app/actions` (e.g., `getUser.ts`)
  2. The **route reference** in `app.js` (e.g., `.action("getUser")`)
  
  Titan uses this convention to automatically wire your application. If they do not match, the action will not be found.
</Callout>

---

## Action file structure

Actions live in the `app/actions` directory.

<Files>
  <Folder name="app" defaultOpen>
    <File name="app.js" />
    <Folder name="actions" defaultOpen>
      <File name="getUser.ts" />
      <File name="compute.rs" />
      <File name="login.js" />
    </Folder>
  </Folder>
</Files>


Each file exports a single function. In JavaScript/TypeScript, it's the `run` or default export. In Rust, it's the `run` function.

---

## Accessing route parameters (`req.params`)

Typed route parameters are validated before the action runs.

```typescript title="app/actions/getUser.ts"
export function run(req: Context) {
  return {
    userId: req.params.id,
  }
}
```

* `req.params.id` is guaranteed to match the declared type
* Invalid parameters never reach the action

---

## Reading query parameters (`req.query`)

Query strings are parsed automatically.

```javascript title="app/actions/search.js"
export function run(req) {
  return {
    q: req.query.q,
  }
}
```

Request:
`GET /search?q=titan`

Result:
`{ "q": "titan" }`

---

## Reading request bodies (`req.body`)

Titan parses request bodies based on content type.

```typescript title="app/actions/login.ts"
export function run(req: Context) {
  const { email } = req.body as { email: string };
  return { email };
}
```

* JSON bodies are parsed automatically
* Invalid payloads are rejected before execution

---

## Returning responses

Actions return plain JavaScript objects (JS/TS) or `IntoResponse` (Rust).

```javascript title="app/actions/example.js"
export function run(req) {
  return {
    success: true,
  }
}
```

Titan automatically:

* Serializes objects to JSON
* Sets appropriate response headers
* Sends the response from native Rust

---

## Returning HTTP errors

Throwing an error signals a failed request.

```js
export function protectedAction(req) {
  if (!req.headers.authorization) {
    throw new Error("Unauthorized")
  }

  return { ok: true }
}
```

Titan converts errors into proper HTTP responses or log on the terminal.

---

## Synchronous and deterministic execution (JS)

JavaScript actions execute synchronously inside Titan‚Äôs embedded JavaScript engine.

* No Node.js runtime
* No event loop
* No background async side effects

This ensures predictable execution and easy reasoning about behavior.

---

## Separation of responsibilities

| Layer       | Responsibility                      |
| ----------- | ----------------------------------- |
| Routes      | URL structure and HTTP methods      |
| Actions     | Request handling and logic          |
| Rust server | Execution, routing, and performance |

This separation keeps applications clean, testable, and maintainable.

---

## Mental model

> Routes describe **structure**
> Actions handle **behavior**
> Titan compiles both into **Rust**

This model scales cleanly from small APIs to large production systems.
